From 96bd73e7c82f02dd1aada2afca79f440460ab275 Mon Sep 17 00:00:00 2001
From: CI Bot <ci-bot@example.com>
Date: Sat, 24 Jan 2026 13:26:37 +0900
Subject: [PATCH] feat(action-manager): persist immediately, load on init,
 track/ack/prune actions; add persistence tests

---
 game/schema/action_manager.js                 | 303 ++++++++++++++++++
 tests/unit/action_manager_persistence.test.js |  77 +++++
 2 files changed, 380 insertions(+)
 create mode 100644 game/schema/action_manager.js
 create mode 100644 tests/unit/action_manager_persistence.test.js

diff --git a/game/schema/action_manager.js b/game/schema/action_manager.js
new file mode 100644
index 0000000..691a15e
--- /dev/null
+++ b/game/schema/action_manager.js
@@ -0,0 +1,303 @@
+/**
+ * @file action_manager.js
+ * @description ActionManager for actionId generation, tracking, and replay support.
+ * Manages the lifecycle of actions from generation to storage.
+ */
+
+(function (root, factory) {
+    if (typeof module === 'object' && module.exports) {
+        module.exports = factory();
+    } else {
+        root.ActionManager = factory();
+    }
+}(typeof self !== 'undefined' ? self : this, function () {
+    'use strict';
+
+    /**
+     * Generate a unique action ID
+     * Format: {timestamp}-{random suffix}
+     * @returns {string}
+     */
+    function generateActionId() {
+        const timestamp = Date.now();
+        const suffix = Math.random().toString(36).substring(2, 8);
+        return `${timestamp}-${suffix}`;
+    }
+
+    /**
+     * ActionManager - tracks actions for replay
+     */
+    const ActionManager = {
+        _actions: [],
+        _currentTurnIndex: 0,
+        _storageKey: 'othello_action_log',
+
+        /**
+         * Reset action log (new game)
+         */
+        reset() {
+            this._actions = [];
+            this._currentTurnIndex = 0;
+        },
+
+        /**
+         * Get current turn index
+         * @returns {number}
+         */
+        getTurnIndex() {
+            return this._currentTurnIndex;
+        },
+
+        /**
+         * Increment turn index (after successful action)
+         */
+        incrementTurnIndex() {
+            this._currentTurnIndex++;
+        },
+
+        /**
+         * Create a new action with required fields
+         * @param {string} type - 'place' | 'pass' | 'use_card' | etc.
+         * @param {string} playerKey - 'black' | 'white'
+         * @param {Object} [data] - Additional action data (row, col, cardId, target, etc.)
+         * @returns {Object} Action with actionId, turnIndex, playerKey, type, and data
+         */
+        createAction(type, playerKey, data) {
+            const action = {
+                actionId: generateActionId(),
+                turnIndex: this._currentTurnIndex,
+                playerKey,
+                type,
+                timestamp: Date.now(),
+                ...data
+            };
+            return action;
+        },
+
+        /**
+         * Record an action (after it succeeds)
+         * - persist to storage immediately for reliability across reloads
+         * @param {Object} action - The action to record
+         */
+        recordAction(action) {
+            const entry = {
+                ...action,
+                recordedAt: Date.now(),
+                acknowledged: false
+            };
+            this._actions.push(entry);
+            // Keep history reasonably bounded to avoid localStorage exhaustion
+            if (typeof this._maxHistory === 'number' && this._actions.length > this._maxHistory) {
+                this._actions = this._actions.slice(-this._maxHistory);
+            }
+            // Persist immediately
+            try { this.saveToStorage(); } catch (e) { /* swallow save errors */ }
+        },
+
+        /**
+         * Get all recorded actions
+         * @returns {Array}
+         */
+        getActions() {
+            return [...this._actions];
+        },
+
+        /**
+         * Get recent action ids (most recent first)
+         * @param {number} [limit]
+         * @returns {Array<string>}
+         */
+        getRecentActionIds(limit) {
+            const ids = this._actions.map(a => a.actionId).filter(Boolean).reverse();
+            return typeof limit === 'number' ? ids.slice(0, limit) : ids;
+        },
+
+        /**
+         * Get unacknowledged actions (for server sync)
+         * @returns {Array}
+         */
+        getUnacknowledgedActions() {
+            return this._actions.filter(a => !a.acknowledged).map(a => ({ ...a }));
+        },
+
+        /**
+         * Mark an action as acknowledged by server
+         * @param {string} actionId
+         */
+        acknowledgeAction(actionId) {
+            let changed = false;
+            for (const a of this._actions) {
+                if (a.actionId === actionId) {
+                    a.acknowledged = true;
+                    changed = true;
+                }
+            }
+            if (changed) {
+                try { this.saveToStorage(); } catch (e) { /* ignore */ }
+            }
+            return changed;
+        },
+
+        /**
+         * Prune acknowledged actions older than keepRecent (keep number of most recent actions)
+         * @param {number} keepRecent
+         */
+        pruneAcknowledged(keepRecent) {
+            if (typeof keepRecent !== 'number') return;
+            const recent = this._actions.slice(-keepRecent);
+            this._actions = recent.concat(this._actions.slice(-keepRecent).filter(a => !a.acknowledged));
+            try { this.saveToStorage(); } catch (e) { /* ignore */ }
+        },
+
+        /**
+         * Get actions for export (minimal format for replay)
+         * @returns {Array}
+         */
+        exportActions() {
+            return this._actions.map(a => ({
+                actionId: a.actionId,
+                turnIndex: a.turnIndex,
+                playerKey: a.playerKey,
+                type: a.type,
+                row: a.row,
+                col: a.col,
+                useCardId: a.useCardId,
+                destroyTarget: a.destroyTarget,
+                swapTarget: a.swapTarget,
+                inheritTarget: a.inheritTarget,
+                temptTarget: a.temptTarget
+            }));
+        },
+
+        /**
+         * Export actions as JSON string (minimal replay-facing format)
+         * @returns {string}
+         */
+        exportAsJSON() {
+            return JSON.stringify(this.exportActions(), null, 2);
+        },
+
+        /**
+         * Import actions from array (for replay)
+         * @param {Array} actions
+         */
+        importActions(actions) {
+            this._actions = actions.map(a => ({
+                ...a,
+                importedAt: Date.now(),
+                acknowledged: !!a.acknowledged
+            }));
+            if (actions.length > 0) {
+                const maxTurnIndex = Math.max(...actions.map(a => a.turnIndex || 0));
+                this._currentTurnIndex = maxTurnIndex + 1;
+            }
+        },
+
+        /**
+         * Save actions to localStorage (if available)
+         * Stores full internal actions (includes acknowledged/timestamp)
+         */
+        saveToStorage() {
+            if (typeof localStorage !== 'undefined') {
+                try {
+                    localStorage.setItem(this._storageKey, JSON.stringify({ actions: this._actions, _maxHistory: this._maxHistory }, null, 2));
+                    return true;
+                } catch (e) {
+                    console.warn('[ActionManager] Failed to save to localStorage:', e);
+                    return false;
+                }
+            }
+            return false;
+        },
+
+        /**
+         * Load actions from localStorage (if available)
+         * Supports older format (array) and new format ({actions, _maxHistory})
+         * @returns {boolean} true if loaded successfully
+         */
+        loadFromStorage() {
+            if (typeof localStorage !== 'undefined') {
+                try {
+                    const data = localStorage.getItem(this._storageKey);
+                    if (data) {
+                        const parsed = JSON.parse(data);
+                        if (Array.isArray(parsed)) {
+                            // Old format: array of minimal actions
+                            this.importActions(parsed);
+                        } else if (parsed && Array.isArray(parsed.actions)) {
+                            this._actions = parsed.actions.map(a => ({ ...a }));
+                            if (typeof parsed._maxHistory === 'number') this._maxHistory = parsed._maxHistory;
+                            if (this._actions.length > 0) {
+                                const maxTurnIndex = Math.max(...this._actions.map(a => a.turnIndex || 0));
+                                this._currentTurnIndex = maxTurnIndex + 1;
+                            }
+                        }
+                        return true;
+                    }
+                } catch (e) {
+                    console.warn('[ActionManager] Failed to load from localStorage:', e);
+                }
+            }
+            return false;
+        },
+
+        /**
+         * Clear saved actions from storage
+         */
+        clearStorage() {
+            if (typeof localStorage !== 'undefined') {
+                try {
+                    localStorage.removeItem(this._storageKey);
+                } catch (e) {
+                    // Ignore
+                }
+            }
+        },
+
+        /**
+         * Get action count
+         * @returns {number}
+         */
+        getActionCount() {
+            return this._actions.length;
+        },
+
+        /**
+         * Get last action
+         * @returns {Object|null}
+         */
+        getLastAction() {
+            return this._actions.length > 0
+                ? this._actions[this._actions.length - 1]
+                : null;
+        }
+    };
+
+    // Defaults and initialization
+    ActionManager._maxHistory = 200;
+
+    /**
+     * Set maximum saved action history to retain in memory/storage
+     * @param {number} n
+     */
+    ActionManager.setMaxHistory = function (n) {
+        if (typeof n === 'number' && n > 0) {
+            this._maxHistory = n;
+            if (this._actions.length > n) this._actions = this._actions.slice(-n);
+            try { this.saveToStorage(); } catch (e) { /* ignore */ }
+        }
+    };
+
+    // Attempt to restore previously-saved actions on load
+    try {
+        ActionManager.loadFromStorage();
+        if (ActionManager.getActionCount() > 0) console.log('[ActionManager] Restored', ActionManager.getActionCount(), 'actions from storage');
+    } catch (e) {
+        // Ignore failures during module init
+    }
+
+    return {
+        generateActionId,
+        ActionManager
+    };
+}));
diff --git a/tests/unit/action_manager_persistence.test.js b/tests/unit/action_manager_persistence.test.js
new file mode 100644
index 0000000..59d6579
--- /dev/null
+++ b/tests/unit/action_manager_persistence.test.js
@@ -0,0 +1,77 @@
+const AMModule = require('../../game/schema/action_manager');
+const ActionManager = AMModule.ActionManager;
+
+afterEach(() => {
+  // Clear any mocked localStorage
+  if (typeof global.localStorage !== 'undefined') {
+    try { localStorage.clear(); } catch (e) { /* ignore */ }
+    delete global.localStorage;
+  }
+  ActionManager.reset();
+});
+
+test('recordAction persists to localStorage and loadFromStorage restores state', () => {
+  // Simple localStorage mock
+  const store = {};
+  global.localStorage = {
+    setItem: (k, v) => { store[k] = v; },
+    getItem: (k) => store[k] || null,
+    removeItem: (k) => { delete store[k]; },
+    clear: () => { for (const k in store) delete store[k]; }
+  };
+
+  ActionManager.clearStorage();
+  ActionManager.reset();
+
+  const action = { actionId: 'a1', turnIndex: 0, playerKey: 'black', type: 'place' };
+  ActionManager.recordAction(action);
+
+  // Ensure it was saved to storage
+  const raw = localStorage.getItem(ActionManager._storageKey);
+  expect(raw).not.toBeNull();
+  const parsed = JSON.parse(raw);
+  expect(parsed && Array.isArray(parsed.actions)).toBe(true);
+  expect(parsed.actions.some(a => a.actionId === 'a1')).toBe(true);
+
+  // Reset in-memory and reload
+  ActionManager.reset();
+  expect(ActionManager.getActionCount()).toBe(0);
+
+  const ok = ActionManager.loadFromStorage();
+  expect(ok).toBe(true);
+  expect(ActionManager.getActionCount()).toBeGreaterThanOrEqual(1);
+  expect(ActionManager.getActions().some(a => a.actionId === 'a1')).toBe(true);
+});
+
+test('acknowledgeAction and getUnacknowledgedActions work and getRecentActionIds returns most recent first', () => {
+  const store = {};
+  global.localStorage = {
+    setItem: (k, v) => { store[k] = v; },
+    getItem: (k) => store[k] || null,
+    removeItem: (k) => { delete store[k]; },
+    clear: () => { for (const k in store) delete store[k]; }
+  };
+
+  ActionManager.reset();
+  ActionManager.clearStorage();
+
+  ActionManager.recordAction({ actionId: 'a1', turnIndex: 0, playerKey: 'black', type: 'place' });
+  ActionManager.recordAction({ actionId: 'a2', turnIndex: 1, playerKey: 'white', type: 'pass' });
+
+  // two unacked
+  const unacked = ActionManager.getUnacknowledgedActions().map(a => a.actionId);
+  expect(unacked).toEqual(expect.arrayContaining(['a1', 'a2']));
+
+  // ack a1
+  const changed = ActionManager.acknowledgeAction('a1');
+  expect(changed).toBe(true);
+
+  const unacked2 = ActionManager.getUnacknowledgedActions().map(a => a.actionId);
+  expect(unacked2).toEqual(['a2']);
+
+  // recent ids most recent first
+  const recent = ActionManager.getRecentActionIds();
+  expect(recent[0]).toBe('a2');
+  expect(recent[1]).toBe('a1');
+
+});
\ No newline at end of file
-- 
2.50.1.windows.1

